"""-*-python-*-
suggested use:
place a dotted symlink to this
file in your home directory
  ln -s /.../pythonrc ~/.pythonrc
and set the environment variable
PYTHONSTARTUP
to the symlink
export PYTHONSTARTUP="${HOME}/.pythonrc"
see also:
https://docs.python.org/3/using/cmdline.html#envvar-PYTHONSTARTUP
"""

from collections import (
    namedtuple,
)
from datetime import (
    datetime as dto,
    timedelta,
)
from functools import (
    reduce,
    partial,
    wraps,
)
from inspect import (
    getmembers as gm,
    getsource,
    getsourcefile as gsf,
    getmodule,
    ismodule,
)
import operator as op
from operator import (
    add,
    itemgetter as ig,
    attrgetter,
)
import os
import sys
import os.path as pth
from pprint import (
    pp,
)
import pydoc

import curses
import curses.textpad


import subprocess
import configparser

import pathlib

from io import (
    BytesIO,
)

from warnings import warn

###


def gmn(*args, **kwargs):
    return [m[0] for m in gm(*args, **kwargs)]


def gs(*args, **kwargs):
    pydoc.pager(getsource(*args, **kwargs))


def pysearch_name(name, maxdepth=3):
    res = []
    permissive_getattr = excepts(
        (ModuleNotFoundError, AttributeError), partial(getattr), lambda _: None
    )

    def name_match(mname):
        return name in mname

    res += [sys.modules[mname] for mname in sys.modules.keys() if name_match(mname)]

    def search_class(cls):
        for mname in dir(cls):
            if name_match(mname):
                res.append(permissive_getattr(cls, mname))

    def search_module(module, depth):
        if depth > maxdepth:
            return
        if name in dir(module):
            res.append(permissive_getattr(module, name))
        for (mname, member) in [
            (mname, permissive_getattr(module, mname)) for mname in dir(module)
        ]:
            if not member:
                continue
            if name_match(mname):
                res.append(member)
            if isinstance(member, type):
                search_class(member)
            if ismodule(member):
                search_module(member, depth + 1)

    for mname in list(sys.modules.keys()):
        search_module(sys.modules[mname], 0)
    return res


ls = os.listdir


def cat(filepath):
    with open(filepath) as f:
        pydoc.pager(f.read())


run = partial(
    subprocess.run,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    # shell=True,
    # check=True,
)

config = configparser.ConfigParser()
config.read(
    [
        os.path.join(os.path.dirname(os.path.realpath(__file__)), "python.conf"),
    ]
)


class PipInstallException(Exception):
    pass


def pip_install(package_name):
    name_to_specifier = {
        name: config["package-specifiers"][name]
        for name in config["package-specifiers"]
    }
    if package_name not in name_to_specifier:
        raise PipInstallException("unknown package", (package_name,))
    res = run(["pip", "install", name_to_specifier[package_name]])
    if res.returncode == 0:
        return
    raise PipInstallException("install failed", (res,))


###
_VENV_DIR = pth.join(str(pathlib.Path().home()), ".pyvenv")
_DEFAULT_VENV = pth.join(_VENV_DIR, "default")
if sys.prefix == sys.base_prefix:
    if not os.getenv("PY_CREATE_VENV"):
        raise Exception("not in venv.  set PY_CREATE_VENV to create")
    venv.create(_DEFAULT_VENV)
    print(". " + pth.join(_DEFAULT_VENV, "bin", "activate"))
    exit()


class ImportBlocker(object):
    def __init__(self):
        self.module_names = set()
        self.package_names = set()

    def find_module(self, fullname, path=None):
        if fullname.split(".")[0] in self.package_names:
            return self
        if fullname in self.module_names:
            return self
        return None

    def exec_module(self, mdl):
        # return an empty namespace
        return {}

    def create_module(self, spec):
        return None


import_blocker = ImportBlocker()
sys.meta_path.append(import_blocker)


def my_except_hook(exctype, value, traceback):
    if exctype is KeyboardInterrupt:
        print("see you later!")
    sys.__excepthook__(exctype, value, traceback)


def install_package(name):
    pass


sys.excepthook = my_except_hook

while True:
    try:
        import toolz
        from toolz.functoolz import (
            compose_left,
            excepts,
            compose,
            curry,
            flip,
            juxt,
        )
        from toolz.itertoolz import (
            accumulate,
            concat,
            concatv,
            diff,
            first,
            isdistinct,
            nth,
            unique,
        )

        #        import numpy as np
        import flask
        import werkzeug

        sys.path.append(os.path.dirname(os.path.realpath(__file__)))
        import pyutils

        sys.path.pop()
        import ics
        import uuid0
    except ModuleNotFoundError as err:
        package_name = err.name
        try:
            print("attempting to install " + package_name)
            pip_install(package_name)
        except PipInstallException as ex:
            if os.getenv("PY_DBG_IMPORTS"):
                breakpoint()
            import_blocker.package_names.add(package_name)
        continue
    break


# reset to orig
# sys.excepthook = sys.__excepthook__

uninstalled_packages = import_blocker.package_names.copy()
if uninstalled_packages:
    print("uninstalled packages")
    print(uninstalled_packages)

###


def edit_text_terminal(text):
    # startup
    stdscr = curses.initscr()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)
    ###

    height, width = stdscr.getmaxyx()
    editwin = curses.newwin(height - 10, width - 10, 1, 1)
    editwin.scrollok(True)
    curses.textpad.rectangle(stdscr, 0, 0, height - 9, width - 9)
    stdscr.refresh()

    box = curses.textpad.Textbox(editwin, insert_mode=True)
    for char in text:
        box.do_command(char)
    # Let the user edit until Ctrl-G is struck.
    box.edit()

    # Get resulting contents
    message = box.gather()

    # exit
    curses.nocbreak()
    stdscr.keypad(False)
    curses.echo()
    curses.endwin()

    return message


def read_ics(filename):
    try:
        with zipfile.ZipFile as zf:
            ics_name = thread_last(
                zf.namelist(),
                (filter, compose_left(pth.splitext, ig(-1), partial(op.eq, ".ics"))),
                first,
                partial(excepts, StopIteration, handler=lambda _: None),
            )
            with zf.open(ics_name) as f:
                cal = ics.Calendar(f.read())
    except zipfile.BadZipFile:
        with open(filename) as f:
            cal = ics.Calendar(f.read())


def pastebin_app(port=5005):
    app = flask.Flask("pastebin")

    pastes = {}

    def store(text, f):
        pastes[str(uuid0.generate())] = {
            "text": text,
            "file": f,
        }

    def retrieve(pid):
        return pastes[pid]

    def paste_ids():
        return list(pastes.keys())

    @app.route("/download/<pid>/<filename>")
    def download(pid, filename):
        paste = retrieve(pid)
        if filename != paste["file"]["name"]:
            warn("url filename not equal to stored filename")
        return flask.send_file(
            BytesIO(paste["file"]["bytes"]),
            attachment_filename=paste["file"]["name"],
        )

    @app.route("/<pid>")
    def look(pid):
        paste = retrieve(pid)
        return (
            (
                """
        <h3>{time}</h3>
        <p>{text}</p>
        """
            ).format(
                time=uuid0.UUID(pid).datetime.isoformat(),
                text=paste["text"],
            )
            + (
                (
                    """
        <a href="{get}">download</a>
        """
                ).format(
                    get=flask.url_for(
                        "download",
                        pid=pid,
                        filename=paste["file"]["name"],
                    ),
                )
                if paste["file"]
                else ""
            )
        )

    @app.route("/", methods=["GET", "POST"])
    def paste():
        text_name = "pastetext"
        file_name = "pastefile"
        if flask.request.method == "POST":
            text = flask.request.form[text_name]
            file_storage = flask.request.files[file_name]
            file_storage.mimetype
            file_name = file_storage.filename
            file_bytes = file_storage.read() if file_storage.filename else None
            store(
                text,
                {
                    "bytes": file_bytes,
                    "name": file_name,
                },
            )

        return """
        <form method="post" enctype="multipart/form-data">
            <textarea name={text} style="width:95vw; height:80vh;"></textarea>
            <p style="height:15vh;">
            <input type=file name={file_name}>
            <input type=submit value=PASTE>
            </p>
        </form>
        <h2>{list_prefix}pastes</h2>
        <ul>{paste_list}</ul>
    """.format(
            text=text_name,
            file_name=file_name,
            list_prefix=("" if paste_ids() else "no "),
            paste_list="".join(
                [
                    """<li><a href="{url}">{pid} - {time}</a></li>""".format(
                        url=flask.url_for("look", pid=pid),
                        time=uuid0.UUID(pid).datetime.isoformat(),
                        pid=pid,
                    )
                    for pid in paste_ids()
                ]
            ),
        )

    werkzeug.serving.run_simple(
        "0.0.0.0",
        port,
        app,
        use_debugger=True,
    )
